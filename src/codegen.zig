const std = @import("std");
const File = std.fs.File;

const expr = @import("expr.zig");
const Expr = expr.Expr;
const ExprKind = expr.ExprKind;
const ExprKindTag = expr.ExprKindTag;
const Value = expr.Value;
const ValueTag = expr.ValueTag;

pub const CodeGenerator = struct {
    const Self = @This();

    exprs: []Expr,
    out_file: File,

    pub fn init(exprs: []Expr, out_file: File) Self {
        return Self{
            .exprs = exprs,
            .out_file = out_file,
        };
    }

    pub fn generate_x86_64_intel_linux(self: *Self) !void {
        var writer = self.out_file.writer();

        // Generate preamble
        try writer.print(
            \\;; Generated by the Chai compiler <https://github.com/Suirabu/chai>
            \\section .text
            \\global _start
            \\_start:
            \\
        , .{});

        for (self.exprs) |e| {
            try writer.print("    ;; {s}\n", .{e.kind});

            switch (e.kind) {
                .Push => |value| {
                    const tag: ValueTag = value;
                    switch (tag) {
                        .Integer => {
                            try writer.print(
                                \\    mov rax, {d}
                                \\    push rax
                                \\
                            , .{value});
                        },
                        else => {
                            std.log.err("{}: Codegen for {} expression is unimplemented", .{ e.src_loc, e.kind });
                            return error.Unimplemented;
                        },
                    }
                },
                .Plus => {
                    try writer.print(
                        \\    pop rbx
                        \\    pop rax
                        \\    add rax, rbx
                        \\    push rax
                        \\
                    , .{});
                },
                .Minus => {
                    try writer.print(
                        \\    pop rbx
                        \\    pop rax
                        \\    sub rax, rbx
                        \\    push rax
                        \\
                    , .{});
                },
                .Multiply => {
                    try writer.print(
                        \\    pop rbx
                        \\    pop rax
                        \\    mul rbx
                        \\    push rax
                        \\
                    , .{});
                },
                .Divide => {
                    try writer.print(
                        \\    pop rbx
                        \\    pop rax
                        \\    div rbx
                        \\    push rax
                        \\
                    , .{});
                },
                .Mod => {
                    try writer.print(
                        \\    mov rdx, 0
                        \\    pop rbx
                        \\    pop rax
                        \\    div rbx
                        \\    push rdx
                        \\
                    , .{});
                },
                .Drop => {
                    try writer.print(
                        \\    pop rax
                        \\
                    , .{});
                },
                .Dup => {
                    try writer.print(
                        \\    pop rax
                        \\    push rax
                        \\    push rax
                        \\
                    , .{});
                },
                .Over => {
                    try writer.print(
                        \\    pop rbx
                        \\    pop rax
                        \\    push rax
                        \\    push rbx
                        \\    push rax
                        \\
                    , .{});
                },
                .Swap => {
                    try writer.print(
                        \\    pop rbx
                        \\    pop rax
                        \\    push rbx
                        \\    push rax
                        \\
                    , .{});
                },
                .Rot => {
                    try writer.print(
                        \\    pop rcx
                        \\    pop rbx
                        \\    pop rax
                        \\    push rbx
                        \\    push rcx
                        \\    push rax
                        \\
                    , .{});
                },
            }
        }

        // Generate post-amble
        try writer.print(
            \\    ;; Exit program with exit code 0
            \\    mov rax, 60
            \\    mov rbx, 0
            \\    syscall
            \\
        , .{});
    }
};
